package;

import peote.view.*;

class Glyph implements Element
{
	// position in pixel (relative to upper left corner of Display)
	@posX public var x:Int;
	@posY public var y:Int;
	
	// size in pixel
	@sizeX @varying public var w:Int;
	@sizeY @varying public var h:Int;
	
	@custom("aGlyph") @varying public var glyph:Int = 0;
	
	@color public var color:Color = 0xff0000ff;
	@color public var bgColor:Color = 0x00000000;
	
	// --------------------------------------------------------------------------	
	
	static public var buffer:Buffer<Glyph>;
	static public var program:Program;	
	
	static public function init(display:Display)
	{	
		buffer = new Buffer<Glyph>(256, 128, true);
		program = new Program(buffer);
		
		program.injectIntoFragmentShader(
		"
			// look at here to generate: http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm

			#define CHARSIZE vec2(8.0, 12.0)

			const vec4 glyphes[95] = vec4[95] (
				vec4(0x000000,0x000000,0x000000,0x000000), // ch_spc
				vec4(0x003078,0x787830,0x300030,0x300000), // ch_exc
				vec4(0x006666,0x662400,0x000000,0x000000), // ch_quo
				vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000), // ch_hsh
				vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000), // ch_dol
				vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000), // ch_pct
				vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000), // ch_amp
				vec4(0x003030,0x306000,0x000000,0x000000), // ch_apo
				vec4(0x000C18,0x306060,0x603018,0x0C0000), // ch_lbr
				vec4(0x006030,0x180C0C,0x0C1830,0x600000), // ch_rbr
				vec4(0x000000,0x663CFF,0x3C6600,0x000000), // ch_ast
				vec4(0x000000,0x18187E,0x181800,0x000000), // ch_crs
				vec4(0x000000,0x000000,0x000038,0x386000), // ch_com
				vec4(0x000000,0x0000FE,0x000000,0x000000), // ch_dsh
				vec4(0x000000,0x000000,0x000038,0x380000), // ch_per
				vec4(0x000002,0x060C18,0x3060C0,0x800000), // ch_lsl
				vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000), // 0
				vec4(0x001030,0xF03030,0x303030,0xFC0000),
				vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000),
				vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000),
				vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000),
				vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000),
				vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000),
				vec4(0x00FEC6,0xC6060C,0x183030,0x300000),
				vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000),
				vec4(0x0078CC,0xCCCC7C,0x181830,0x700000), // 9
				vec4(0x000000,0x383800,0x003838,0x000000), // ch_col
				vec4(0x000000,0x383800,0x003838,0x183000), // ch_scl
				vec4(0x000C18,0x3060C0,0x603018,0x0C0000), // ch_les
				vec4(0x000000,0x007E00,0x7E0000,0x000000), // ch_equ
				vec4(0x006030,0x180C06,0x0C1830,0x600000), // ch_grt
				vec4(0x0078CC,0x0C1830,0x300030,0x300000), // ch_que
				vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000), // ch_ats
				vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000), // A
				vec4(0x00FC66,0x66667C,0x666666,0xFC0000),
				vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000),
				vec4(0x00F86C,0x666666,0x66666C,0xF80000),
				vec4(0x00FE62,0x60647C,0x646062,0xFE0000),
				vec4(0x00FE66,0x62647C,0x646060,0xF00000),
				vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000),
				vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000),
				vec4(0x007830,0x303030,0x303030,0x780000),
				vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000),
				vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000),
				vec4(0x00F060,0x606060,0x626666,0xFE0000),
				vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000),
				vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000),
				vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000),
				vec4(0x00FC66,0x66667C,0x606060,0xF00000),
				vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00),
				vec4(0x00FC66,0x66667C,0x6C6666,0xE60000),
				vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000),
				vec4(0x00FCB4,0x303030,0x303030,0x780000),
				vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000),
				vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000),
				vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000),
				vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000),
				vec4(0x00CCCC,0xCCCC78,0x303030,0x780000),
				vec4(0x00FECE,0x981830,0x6062C6,0xFE0000), // Z
				vec4(0x003C30,0x303030,0x303030,0x3C0000), // ch_lsb
				vec4(0x000080,0xC06030,0x180C06,0x020000), // ch_rsl
				vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000), // ch_rsb
				vec4(0x10386C,0xC60000,0x000000,0x000000), // ch_pow
				vec4(0x000000,0x000000,0x000000,0x00FF00), // ch_usc
				                                           // no ` here
				vec4(0x000000,0x00780C,0x7CCCCC,0x760000), // a
				vec4(0x00E060,0x607C66,0x666666,0xDC0000),
				vec4(0x000000,0x0078CC,0xC0C0CC,0x780000),
				vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000),
				vec4(0x000000,0x0078CC,0xFCC0CC,0x780000),
				vec4(0x00386C,0x6060F8,0x606060,0xF00000),
				vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78),
				vec4(0x00E060,0x606C76,0x666666,0xE60000),
				vec4(0x001818,0x007818,0x181818,0x7E0000),
				vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78),
				vec4(0x00E060,0x60666C,0x786C66,0xE60000),
				vec4(0x007818,0x181818,0x181818,0x7E0000),
				vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000),
				vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000),
				vec4(0x000000,0x0078CC,0xCCCCCC,0x780000),
				vec4(0x000000,0x00DC66,0x666666,0x7C60F0),
				vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E),
				vec4(0x000000,0x00EC6E,0x766060,0xF00000),
				vec4(0x000000,0x0078CC,0x6018CC,0x780000),
				vec4(0x000020,0x60FC60,0x60606C,0x380000),
				vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000),
				vec4(0x000000,0x00CCCC,0xCCCC78,0x300000),
				vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000),
				vec4(0x000000,0x00C66C,0x38386C,0xC60000),
				vec4(0x000000,0x006666,0x66663C,0x0C18F0),
				vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000), // z
				vec4(0x001C30,0x3060C0,0x603030,0x1C0000), // ch_lpa
				vec4(0x001818,0x181800,0x181818,0x180000), // ch_bar
				vec4(0x00E030,0x30180C,0x183030,0xE00000), // ch_rpa
				vec4(0x0073DA,0xCE0000,0x000000,0x000000), // ch_tid
				vec4(0x000000,0x10386C,0xC6C6FE,0x000000)  // ch_lar
			);

			float get_bit(float n, float b)
			{
				b = clamp(b, -1.0, 24.0);
				return floor( mod( floor(n/pow(2.0,floor(b)) ), 2.0) );   
			}


			float glyph_pixel( vec2 texCoord, float glyphnumber)
			{
				texCoord = floor( vec2(texCoord.x, 1.0 - texCoord.y) * CHARSIZE );
				
				float bit = (CHARSIZE.x - texCoord.x - 1.0) + texCoord.y * CHARSIZE.x;

				vec4 g = glyphes[int(glyphnumber)];

				float intensity = 0.0;
				intensity += get_bit(g.x, bit - 72.0);
				intensity += get_bit(g.y, bit - 48.0);
				intensity += get_bit(g.z, bit - 24.0);
				intensity += get_bit(g.w, bit - 00.0);

				// bounds
				intensity = (all(greaterThanEqual(texCoord,vec2(0.0))) && all(lessThan(texCoord,CHARSIZE))) ? intensity : 0.0;

				return intensity;
			}			
		"
		);
		
		program.setColorFormula( 'mix( bgColor, color, glyph_pixel(vTexCoord, aGlyph) )' );
		
		// program.blendEnabled = true;
		program.discardAtAlpha(0.0);
		display.addProgram(program);
	}
	
	
	
	public function new(x:Int, y:Int, w:Int, h:Int, char:String, color:Color, bgColor:Color = 0) 
	{
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;

		var charcode = char.charCodeAt(0);

		// glyphes starts with the "space" char .)
		charcode -= 32;
		
		// fix the missing char
		if (charcode > 63) charcode--;

		this.glyph = charcode;

		this.color = color;
		this.bgColor = bgColor;

		buffer.addElement(this);
	}
	
	public function update() buffer.updateElement(this);

}
